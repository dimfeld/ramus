import { EventEmitter } from 'events';
import { ChronicleClient, ChronicleClientOptions, RunContext, runStep } from '@dimfeld/chronicle';
import type { AnyInputs, Dag, DagNodeState } from './types.js';
import { CompiledDag } from './compile.js';
import { DagNodeRunner } from './node_runner.js';
import { getEventContext } from '@dimfeld/chronicle';
import { NodeResultCache } from '../cache.js';
import { Semaphore } from '../semaphore.js';
import { Runnable, RunnableEvents } from '../runnable.js';
import { uuidv7 } from 'uuidv7';

export interface DagRunnerOptions<CONTEXT extends object, ROOTINPUT, OUTPUT = unknown> {
  /** A UUID for this DAG instance. Autogenerated as a UUIDv7 if omitted */
  id?: string;
  /** A name for this run, which will be concatenated with the name from the DAG configuration. */
  name?: string;
  dag: Dag<CONTEXT, ROOTINPUT> | CompiledDag<CONTEXT, ROOTINPUT, OUTPUT>;
  input: ROOTINPUT;
  cache?: NodeResultCache;
  context?: CONTEXT;
  /** Semaphores which can be used to rate limit operations by the DAG. This accepts multiple Semaphores, which
   * can be used to provide a semaphore for global operations and another one for this particular DAG, for example. */
  semaphores?: Semaphore[];
  /** A Chronicle LLM proxy client, if not inheriting it from an existing run or using the global client */
  chronicle?: ChronicleClient;
  /** A function that returns if the DAG should run nodes whenever they become ready, or wait for an external source to
   * run them. */
  autorun?: () => boolean;

  /** Info to merge with the DAG config's info, for logging. */
  info?: object;

  /** Use this RunContext instead of finding it from the current context. */
  parentRunContext?: RunContext;
}

type DagRunnerEvents<OUTPUT> = {
  'dag:state': [{ sourceNode: string; source: string; state: DagNodeState }];
} & RunnableEvents<OUTPUT>;

export class DagRunner<CONTEXT extends object, ROOTINPUT, OUTPUT>
  extends EventEmitter<DagRunnerEvents<OUTPUT>>
  implements Runnable<OUTPUT, DagRunnerEvents<OUTPUT>>
{
  name: string;
  tags?: string[];
  info?: object;
  context?: CONTEXT;
  runners: Map<string, DagNodeRunner<CONTEXT, ROOTINPUT, AnyInputs, any>>;
  outputNode: DagNodeRunner<CONTEXT, ROOTINPUT, AnyInputs, OUTPUT>;
  tolerateFailures: boolean;
  autorun: () => boolean;
  input: ROOTINPUT;
  output: OUTPUT | undefined;
  /* A promise which resolves when the entire DAG finishes or rejects on an error. */
  _finished: Promise<OUTPUT> | undefined;

  constructor({
    name,
    dag,
    context,
    input,
    cache,
    autorun,
    semaphores,
    info,
  }: DagRunnerOptions<CONTEXT, ROOTINPUT, OUTPUT>) {
    super();
    if (!(dag instanceof CompiledDag)) {
      dag = new CompiledDag(dag);
    }

    this.context = context;
    this.input = input;

    const { runners, outputNode } = dag.buildRunners({
      context: this.context,
      input: this.input,
      cache,
      autorun,
      semaphores,
    });

    this.runners = runners;
    this.outputNode = outputNode;

    this.name = name ? `${name}: ${dag.config.name}` : dag.config.name;
    this.tags = dag.config.tags;
    this.info = {
      ...dag.config.info,
      ...info,
    };
    this.tolerateFailures = dag.config.tolerateFailures ?? false;
    this.autorun = autorun ?? (() => true);
  }

  get finished() {
    if (!this._finished) {
      // TODO Check for if we're already resolved or errored
      this._finished = new Promise((resolve, reject) => {
        this.once('finish', resolve);
        this.once('cancelled', () => {
          reject(new Error('Cancelled'));
        });
        this.once('ramus:error', (e) => reject(e.error));
      });
    }

    return this._finished;
  }

  /** Run the entire DAG to completion */
  run(): Promise<unknown> {
    return runStep(
      {
        name: this.name,
        type: 'dag',
        input: this.input,
        tags: this.tags,
      },
      async (eventContext) => {
        for (let runner of this.runners.values()) {
          runner.setRunContext(eventContext);
          if (!this.tolerateFailures) {
            runner.on('ramus:error', (e) => {
              // Make sure to emit error before we cancel, so that anything listening to both will know about the
              // error first.
              this.emit('ramus:error', e);
              this.cancel(false);
            });
          }
        }

        this.outputNode.setRunContext(eventContext);

        const result = Promise.withResolvers();

        this.outputNode.on('ramus:error', (e) => {
          this.cancel(false);
          this.emit('ramus:error', e);
          result.reject(e.error);
        });

        this.outputNode.on('finish', (e) => {
          this.output = e.output;
          this.emit('finish', e.output);
          result.resolve(e);
        });

        if (this.autorun()) {
          for (let runner of this.runners.values()) {
            if (runner.readyToResume()) {
              runner.run();
            }
          }
        }

        return result.promise;
      }
    );
  }

  cancel(emit = true) {
    for (let runner of this.runners.values()) {
      runner.cancel();
    }

    if (emit) {
      this.emit('cancelled');
    }
  }
}

/** Create a run a DAG in one statement, for simple cases.*/
export async function runDag<CONTEXT extends object, INPUT, OUTPUT>(
  options: DagRunnerOptions<CONTEXT, INPUT, OUTPUT>
) {
  let runner = new DagRunner(options);
  runner.run();
  return runner.finished;
}
